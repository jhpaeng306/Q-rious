import pennylane as qml
import pandas as pd
from pennylane import numpy as np

qubitn = 3
dev = qml.device("lightning.qubit", wires=range(qubitn), shots=1)



def preFuncPair(weight, bias, data1, data2):
    t = np.tensordot(data1, weight, ((0), (1))) - bias
    T = np.tensordot(data2, weight, ((0), (1))) - bias

    layerN = t.shape[0]
    for j in range(layerN - 1):
        for i in range(t.shape[1] // 2):
            qml.RX(t[j, 2 * i], wires=i)
            qml.RZ(t[j, 2 * i + 1], wires=i)
        for i in range(t.shape[1] // 2 - 1):
            qml.CNOT(wires=[i, i + 1])
    for i in range(t.shape[1] // 2):
        qml.RX(t[layerN - 1, 2 * i], wires=i)
        qml.RZ(t[layerN - 1, 2 * i + 1], wires=i)

    for j in range(layerN - 1, 0, -1):
        for i in range(t.shape[1] // 2 - 1, -1, -1):
            qml.RZ(-T[j, 2 * i + 1], wires=i)
            qml.RX(-T[j, 2 * i], wires=i)
        for i in range(t.shape[1] // 2 - 2, -1, -1):
            qml.CNOT(wires=[i, i + 1])
    for i in range(t.shape[1] // 2 - 1, -1, -1):
        qml.RZ(-T[0, 2 * i + 1], wires=i)
        qml.RX(-T[0, 2 * i], wires=i)

def preFunc(weight, bias, data):
    t = np.tensordot(data, weight, ((0), (1))) - bias

    layerN = t.shape[0]
    for j in range(layerN - 1):
        for i in range(t.shape[1] // 2):
            qml.RX(t[j, 2 * i], wires=i)
            qml.RZ(t[j, 2 * i + 1], wires=i)
        for i in range(t.shape[1] // 2 - 1):
            qml.CNOT(wires=[i, i + 1])
    for i in range(t.shape[1] // 2):
        qml.RX(t[layerN - 1, 2 * i], wires=i)
        qml.RZ(t[layerN - 1, 2 * i + 1], wires=i)


def postfunc(params):
    N = len(params) // (qubitn * 2)
    for j in range(N):
        for i in range(qubitn):
            qml.RX(params[i * 2], wires=i)
            qml.RZ(params[i * 2 + 1], wires=i)
        for i in range(qubitn - 1):
            qml.CNOT(wires=[i, i + 1])


@qml.qnode(dev)
def preCircuitPair(weight, bias, data1, data2):
    preFuncPair(weight, bias, data1, data2)
    return qml.probs(wires=range(qubitn))

@qml.qnode(dev)
def fullCircuit(weight, bias, postParams, data):
    preFunc(weight, bias, data)
    postfunc(postParams)
    return qml.probs(wires=range(qubitn))

@qml.qnode(dev)
def classifyingCircuit(weight, bias, postParams, data):
    preFunc(weight, bias, data)
    postfunc(postParams)
    return qml.probs(wires=range(qubitn))

def searchProbability():
    while True:
        [A,B]=input().split(' ')
        A=int(A)
        B=int(B)
        data1=np.array(oneData[A,:])
        data2=np.array(oneData[B,:])
        print(fullCircuit(weight,bias,postParam,data1))
        print(fullCircuit(weight,bias,postParam,data2))
        print(preCircuitPair(weight,bias,data1,data2))

def classify(oneData):
    for i in range(oneData.shape[0]):
        data=np.array(oneData[i,:])
        print('data Set',i,end=' ')
        while True:
            result=classifyingCircuit(weight,bias,postParam,data)
            resultMax=np.argmax(result)
            if (resultMax==2):
                print('B',end=' ')
                break
            elif (resultMax==0 or resultMax==1 or resultMax==3):
                print('A',end=' ')
                break
        print('')
            
        


weight = [[[-0.30925210408936493,-0.007175905380512222,0.006595319419103151,-0.012935116413675049,0.12388541133249922,0.18573619435436026],[-0.10195125945251218,-0.003186710658489302,-0.006431718976443067,0.012411156928224394,0.14590322980221296,0.242823639046606],[1.410974316846665,0.004863397960644366,-0.03286001728344276,0.03701346644277903,-0.6251169942597914,-1.1893987058528774],[0.774519669753791,0.004844413159998628,-0.021036111852198714,-0.0038453447985330558,-0.48136696143379787,-0.7513537333348278]],[[0.30947562356191965,0.04418148107413806,-0.012832993373428712,0.023102590203107187,0.1266407049315765,0.03797298906020587],[0.09966986235181886,-0.08104138807338902,0.04873392774678778,0.1500669122634272,0.09281421078273434,0.0910755292134561],[-1.408969781922362,-0.01616865788628495,-0.15281643389818772,-0.3541013790295403,-0.6284737483078835,-0.16697991461123154],[-0.7700344020203888,-0.0006254692079218168,0.30529515151207975,-0.2553136646222347,-0.8098384118370571,-0.17862238681559556]],[[-0.0032416502821970552,-0.025409362051489144,0.10942882530553336,-0.001349315812765433,-0.05719955587134022,-0.07822149623753824],[-0.012829862908905825,0.013222556927441769,0.05251091455807551,-0.0942172547729733,-0.05585667482374196,-0.23101205242475342],[0.011920156937690995,-0.10398445137229544,-0.4973011164788991,0.32439140374820064,0.279612403923888,0.7394504701796882],[0.015408097373414273,-0.08206568851334214,-0.36089564847371336,0.3082632817965115,0.3859219913185011,0.5450014582119219]],[[0.0037897447953294276,0.06139984290870199,0.04379959065260546,-0.07078063108128983,0.0923569279395629,-0.06967891828369276],[0.008154608555532138,0.05265312939621007,0.10794013344016194,-0.18929674394609586,0.06963851319321336,-0.17379936873262608],[0.007743982427380597,-0.27755212516258715,-0.2304489302461011,0.4599669695093131,-0.2490345691561281,0.350979806339717],[0.00357383865102905,-0.04814708231289914,-0.17213803667227293,0.39775912570803595,-0.30070065918184197,0.385297300576474]],[[-0.0005345143256678297,0.014500712805298945,0.004685956471868107,0.001594794603588165,-0.02225390047649108,0.012108730491385195],[0.002571749005533985,0.008991012115643572,-0.007709691992027879,-0.004164161401141486,0.04067619299451154,-0.007088720637838152],[-0.0008717359766229967,0.01600128713279797,-0.007784102688509933,0.040888905106676005,-0.10453289898722903,0.03526140415140034],[0.0016135069386920605,0.040534402318802815,-0.006982772613226436,0.029806183802041405,-0.09783349837633541,0.03302120464369365]]]
bias = [[-0.3024209984598243,0.008939375520892355,1.5788211642991403,1.6156981205740526,1.3415215135085408,1.7030838681174965],[0.3040640022304194,0.4128844711618273,1.1119834152963788,1.2791188701725695,-1.20765991478133,1.1938335279619734],[0.03577337738083753,-0.05937239398468259,0.2148144915747455,-0.43967143244668566,-0.35677229311383196,0.049311740720275554],[-0.02284419200424428,-0.0028231980835837864,-0.8910556920208298,-0.009661486263705221,-0.8653736294929696,-0.017246762478867864],[-0.07086168231069778,-1.5659522802296256e-12,0.08604216709830485,1.7232333880982916e-11,-0.09714533424500316,3.241344067082717e-11]]
postParam = [0.1923435053605735,-0.04124274217273233,0.08600963163164595,-0.7759065041443172,0.7348880058511964,-0.5522184023473248,0.0807975864030244,2.0012563301144426,0.9427611457553229,-1.189364210029412,-0.14045366507418508,1.4160804613826907,-0.7550396090230582,0.9721671504477858,-0.20673248178942952,0.7749679144575999,0.08241364240154872,-0.99330831992611,0.15477360662972933,3.1816044710608793,-0.9713137630330276,-0.6293047412688794,0.547851851099825,-0.20957834630437702,-0.2248519443287148,0.43499479824985593,0.3178438048500874,0.14913204089812102,-0.6581089709903832,-0.21079933457438133]

weight = np.array(weight)
bias = np.array(bias)
postParam = np.array(postParam)

oneData = pd.read_csv('onedata_iris.csv').iloc[:, 1:].to_numpy()

#searchProbability()

classify(oneData)
